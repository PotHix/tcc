\section{HTML5 para o desenvolvimento de jogos casuais}

Nesse capítulo será abordado as ferramentas mais utilizadas para
desenvolvimento de jogos casuais dentro do ambiente HTML5.
As ferramentas atuais que suportam HTML5 possuem muitas vantagens,
principalmente em portabilidade, tirando do desenvolvedor a
responsabilidade de implementação de código para várias plataformas, mas
com isso também introduz algumas limitações para que o jogo
desenvolvido possa funcionar em vários dispositivos e sistemas
operacionais. Esse capítulo visa mostrar as vantagens e desvantagens
de cada uma das ferramentas utilizadas no HTML5, o que pode ser usado
com tranquilidade e o que necessita de mais cautela no seu uso.

\subsection{Javascript}

Como dito no capítulo anterior, Javascript é a principal ferramenta
quando se vai trabalhar em um jogo com HTML5, pois é ela que vai
manipular as propriedades dos elementos para passar ao jogador a
impressão de movimento do protagonista do jogo.
Javascript é uma linguagem muito poderosa que suporta vários tipos de
sintaxes, e possui muitas vantagens de uma linguagem de alto nível,
como por exemplo coletor de lixo (garbage collector), e tipagem
dinâmica, o que ajuda o desenvolvedor a se preocupar menos com tipos
de variáveis e elementos, e evita a grande preocupação com o
gerenciamento de memória.
Como desvantagem, o Javascript tende a expor o código do jogo em
questão para a internet, pois, para que um navegador execute o jogo é
necessário que o mesmo possua o código, tendo em vista que Javascript
não é uma linguagem compilada, e sim interpretada. Uma das técnicas
utilizadas para evitar a distribuição do código para o usuário é a
ofuscação de código. Com essa técnica o seu código continua chegando
ao usuário, mas de uma maneira não legível, ou seja, será facilmente
entendida pelo navegador mas dificilmente entendida por um humano que
quer utilizar seu código fonte.
Uma das grandes preocupações de todos os desenvolvedores de jogos é a
performance. A área de jogos exige muito processamento para calcular
cada um dos passos que um jogador vai dar dentro de um jogo, como cada
objeto vai se comportar, calcular trajetórias de projéteis, calcular
iluminação dos objetos da cena, calcular a física dos objetos e outras
coisas, e para isso é necessário utilizar muito processamento do
dispositivo que estiver executando o mesmo. Sabemos que Javascript vai
ser interpretado em cima de um navegador, que por sua vez está sendo
executado pelo sistema operacional e dividindo memória e processamento
com outros programas no escalonador de processos, portanto, não
podemos esperar que um jogo que vai rodar no navegador tenha as mesmas
capacidades que um jogo que executa nativamente no sistema
operacional, com código compilado para a própria plataforma.
Tendo em mente a média de performance que é exigida por um jogo,
podemos levar em consideração que um jogo casual que utiliza apenas
coisas simples, como física básica, calculo de trajetórias e
movimentação de imagens é totalmente aceitável para ser executado em
dispositivos que possuem baixa performance, desde que bem executado.

\subsection{Navegadores}

Os navegadores são a parte fundamental para a execução do jogo, pois
ele é a plataforma de desenvolvimento que o desenvolvedor está visando,
ou seja, assim como muitas grandes empresas visam vídeo games,
computadores ou celulares, como plataforma alvo de desenvolvimento, o
desenvolvedor deve ter em mente que está desenvolvendo para o
navegador, e estar ciente de suas vantagens, desvantagens e
limitações.

Um dos grandes problemas de se trabalhar com navegadores é a
fragmentação, pois o desenvolvedor deve pensar em quais navegadores e
dispositivos o seu jogo estará disponível, levando em consideração
que cada usuário vai escolher seu navegador preferido, e que talvez
esse navegador não estará na ultima versão. Atualmente vários sites na
internet descrevem quais funcionalidades do HTML5 estão disponíveis em
qual navegador, um deles é o dive into html5. \cite{diveintohtml5}.
Esse problema acontece também no desenvolvimento para computadores e
vídeo games, mas é um pouco mais simples de lidar, pois os jogos
simplesmente não são compatíveis, ou seja, se você tem um computador
que o hardware não é bom o suficiente para executar um jogo, ele será
barrado já na instalação, ou será executado mas será impossível de ser
jogado devido a sua lentidão. O mesmo acontece com os jogos no
navegador, caso o navegador não tenha suporte as funcionalidades que o
jogo precisa, ele simplesmente não irá ser executado. Enquanto o
desenvolvimento do jogo estiver sendo feito, o desenvolvedor deve ter
definido quais são as plataformas alvo do seu jogo, pois, apesar de
estar lidando com navegadores, que podem executar em uma grande
quantidade de plataformas, é nítido que não será possível ter a mesma
performance em todas elas, tendo em vista que um computador pessoal
possui muito mais capacidade de processamento do que um celular, por
exemplo.

O problema da fragmentação pode ser mais facilmente contornado quando
o desenvolvedor fixa algumas configurações, como por exemplo a versão
dos navegadores suportados. A liberdade do desenvolvedor é total,
bastando apenas ter em mente o quanto de processamento será utilizado
e quais funcionalidades serão necessárias para a execução do jogo.

\subsection{Canvas}

O Canvas prove uma interface com resolução de dependências para
desenhar coisas diretamente no navegador, e pode ser utilizado para
gerar gráficos, gráficos de jogos, e outras imagens para ser
visualizadas no momento da execução. \cite{w3ccanvas}.

O canvas na web segue a mesma interface que é utilizada nas grandes
plataformas atuais. O conceito de canvas foi criado pela Apple para
utilizar no webkit do MacOS X \cite{lubbers2010pro}, criando uma API
para desenhar widgets e outras coisas em sua plataforma, e essa API
vem sendo padronizada e implementada em vários navegadores.

Essa tecnologia é fundamental para o desenvolvimento de jogos para
o navegador, pois permite ao desenvolvedor uma forma de exibir
objetos e manipulá-los da mesma forma que é feito com jogos
simples em duas dimensões para computadores.
Diferentemente do DOM, que cria vários objetos que podem ser
manipulados individualmente pelo navegador, o canvas quando criado
gera apenas um elemento no navegador, e todos os elementos criados
no nesse elemento (imagens, retângulos e etc) ficam invisíveis para acesso, e
não podem ser modificados, apenas recriados.

O canvas pode ser utilizado em várias camadas, gerando vários
elementos canvas dentro do navegador, e posicionando-os no mesmo
lugar, assim facilitando a manipulação de cenário e melhorando a
performance.

Exemplo do jogo Angry Birds na Figura~\ref{img:angrybirds}, que
utiliza canvas com várias camadas para a renderização padrão.

\newlength{\imgwidth}
\setlength{\imgwidth}{16.09cm}
\newlength{\imgheight}
\setlength{\imgheight}{10.59cm}

\begin{figure}[H]
  \centering
	\includegraphics[height=\imgheight,width=\imgwidth]{angrybirds}
  \caption{Angry Birds {--} Utilizando canvas em varias camadas}
  \label{img:angrybirds}
\end{figure}

\clearpage


\subsection{SVG}

SVG é uma linguagem de marcação utilizada para descrever aplicações de gráficos
bi-dimensionais e imagens, e um conjunto de script relacionados a
interfaces gráficas. \cite{w3csvg}. Essa linguagem é utilizada por
editores como o Inkscape para definir os vetores criados por ele.

Comparando SVG com Canvas, é possível verificar uma grande diferença
em termos de desenho. SVG é utilizado para construir desenhos
vetoriais que podem ser facilmente modificados, diferentemente do
canvas, que possui uma particularidade de não poder ser alterado, ou
seja, após um objeto canvas ser desenhado, ele não pode ser mais
modificado, apenas redesenhado.

Com SVG também é possível fazer animações, assim possibilitando a
criação de mídias mais interativas, como logotipos animados e pequenas
animações de introdução.

Na Figura~\ref{img:timetrap}, é possível ver o logo da empresa
Timetrap, que foi desenvolvido apenas com SVG, utilizando animações. O
logo animado pode ser visto em
http://files.myopera.com/emoller/blog/timetrap.html conforme \cite{svgtimetrap}.

\begin{figure}[H]
  \centering
	\includegraphics[height=\imgheight,width=\imgwidth]{timetrap}
  \caption{Logo da empresa Timetrap {--} Utilizando apenas vetores SVG para sua construção}
  \label{img:timetrap}
\end{figure}

\clearpage

No desenvolvimento de jogos a utilização do SVG é bem limitada, sendo
comumente utilizada para as animações acima citadas. O motivo do SVG
não ser utilizado para o desenho dos jogos é a dificuldade e
performance de alterar cada um dos vetores, por esse motivo,
a técnica de sprites é mais utilizada, favorecendo imagens pré-feitas
ao invés da manipulação de vetores.


\subsection{WebSocket API}

WebSocket API define uma especificação que permite as páginas web
utilizar o protocolo de Sockets para utilizar uma comunicação em duas
vias com um servidor remoto. \cite{w3cwebsockets}. Com essa tecnologia
conseguimos facilmente criar jogos multiplayer, pois podemos
trocar informações entre dois computadores de uma maneira bem mais
veloz, trafegando menos dados e recebendo as informações mais
rapidamente.
O que traz essa velocidade na comunicação via internet é não utilizar
o método normal de comunicação que o HTTP fornece, e sim utilizar um
túnel direto entre o computador e o servidor.
Nos métodos normais de comunicação utilizando o HTTP a cada requisição
é necessário passar por todo o processo de comunicação do TCP, e
receber todos os dados e metas do HTTP, o que gera um tempo maior para
o recebimento dos dados e um maior trafego de rede. Com o Socket (que
é criados pela funcionalidade de WebSockets), apenas uma conexão TCP é
criada e mantida durante um período de tempo, assim facilitando o
tráfego de informações viabilizando uma comunicação mais rápida e
usável para um jogo em tempo real.

Websockets possibilita uma redução de 500 para 1 ou até 1000 para 1
(em alguns casos) de cabeçalhos de HTTP desnecessários, e até 3 para 1
em latência. \cite{lubbers2010pro}.

Na Figura~\ref{img:swarmation}, é apresentado um jogo que utiliza
uma biblioteca que disponibiliza uma interface de código WebSockets,
se utilizando de diferentes ferramentas para que essa interface seja a mesma em
todos os navegadores, inclusive os que não possuem suporte para essa
tecnologia.

A ideia do jogo é integrar vários jogadores em um único lugar, sendo que
cada jogador assume o papel de um pixel, e eles precisam formar uma
determinada imagem que é gerada aleatoriamente pelo jogo e mostrada a
direita. A função do WebSockets nesse jogo é sincronizar em tempo real a
posição de cada jogador para que ao final da contagem possa ser
calculado os posicionamentos para saber quais imagens foram formadas e
quais jogadores devem ser pontuados.

\begin{figure}[H]
  \centering
	\includegraphics[height=\imgheight,width=\imgwidth]{swarmation}
  \caption{Swarmation {--} Jogo casual simples que utiliza Websockets}
  \label{img:swarmation}
\end{figure}

\clearpage


\subsection{Offline cache}

Offline cache, em sua maneira mais simplista, é uma lista apontando
para o HTML, CSS, Javascript, imagens e outros recursos que devem
estar disponíveis para o website. \cite{pilgrim2010html5}. Utilizando
essa lista o navegador faz o download de todos os recursos que
precisam ser utilizados quando o dispositivo em questão não estiver
apto a acessar a internet, ou seja, na primeira requisição, tudo que estiver
disponível no arquivo de manifesto que contem essa lista será baixado
e guardado no dispositivo e será utilizado até que o manifesto seja
modificado.

A cada nova requisição de uma aplicação que utiliza offline cache o
navegador verifica o arquivo de manifesto, se ele não foi modificado
o navegador vai utilizar os arquivos que estão disponíveis localmente,
caso contrário todos os arquivos da seção "CACHE" desse arquivo serão baixados novamente.

A funcionalidade de offline cache também prevê as requisições que não
podem ser guardadas localmente, requisições que precisam
necessariamente estar online para funcionar corretamente, e para isso
existe uma seção chamara REMOTE no arquivo manifesto, definindo quais
são os arquivos que não devem ser considerados quando o usuário não
estiver offline.

Todos os arquivos utilizados na aplicação devem estar no arquivo de
manifesto, para os arquivos que não estarão disponíveis localmente há
uma seção chamada FALLBACK.

Utilizando Offline cache é possível criar uma aplicação para a
internet que funcione normalmente sem a necessidade do usuário estar
conectado. Um exemplo dessa funcionalidade foi feito na aplicação da
Figura~\ref{img:currency}. A aplicação em questão pode ser adicionada
no celular como um favorito (no caso do iPhone, pode ser adicionado
como um novo aplicativo à tela principal do aparelho) e ser utilizada
normalmente como se fosse uma aplicação nativa.

\begin{figure}[H]
  \centering
	\includegraphics[height=\imgheight,width=\imgwidth]{currency}
  \caption{Offline cache {--} Currency.io utilizando offline cache
  para fazer uma aplicação que ficará disponível mesmo sem acesso a
  internet.}
  \label{img:currency}
\end{figure}

\clearpage

Essa funcionalidade pode ser muito utilizado em jogos casuais, para disponibilizar um
determinado para utilização em um dispositivo móvel, bastando
adicionar o jogo aos favoritos, e ele estará disponível a qualquer
momento.


\subsection{Local Storage}

Local Storage do HTML5 provê aos websites uma maneira de guardar
informações e recuperá-las depois, utilizando um conceito similar aos
cookies, mas já pensando em um grande modelo de dados. \cite{pilgrim2010html5}.
Por muito tempo os desenvolvedores utilizaram cookies para guardar
informações sobre o website diretamente no navegador do usuário, e
essa tecnologia se provou muito ineficiente para uma quantidade um
pouco maior de dados, pois além de ser limitado para guardar informações,
os dados ficam trafegando pela rede em cada requisição, consumindo
banda, expondo os dados, e deixando as requisições mais lentas.

O Local storage foi criado para resolver esses problemas, dando uma
interface simples para o desenvolvedor guardar dados de sua
aplicação diretamente no navegador do usuário. Para guardar tais dados
o desenvolvedor utiliza um banco que armazena dados seguindo um
esquema chave-valor, ou seja, uma chave como índice, associado a um
determinado valor, que será convertido para texto quando adicionado.

Essa funcionalidade é muito utilizada em conjunto com a funcionalidade
de offline cache, pois quando uma aplicação não possui conexão com a
internet é necessário utilizar localStorage para guardar informações
que serão sincronizadas com o servidor assim que a aplicação possuir
conexão com a internet novamente.
%TODO: Dar um exemplo de uso de localstorage e falar de sua utilização em jogos casuais

\subsection{Audio}
%TODO: escrever sobre a tag audio
Yes, we can!

\subsection{WebGL}
%TODO: escrever sobre webgl

WebGL é uma API para gráficos 3D na web. \cite{lubbers2010pro}.
WebGL é um mapeamento do OpenGL ES2 em Javascript. \cite{lubbers2010pro}.

Suporta shaders

baseado na tag canvas, mas utiliza o contexto 3d ao invés do 2d.

Na Figura~\ref{img:webglmodels} é possível ver modelos 3D no formato
MD2 (o mesmo formato que o jogo Quake II utilizava para seus
personagens) utilizando WebGL para a renderização. Isso é feito utilizando a
biblioteca GLGE, que é um facilitador para a utilização do WebGL.

\begin{figure}[H]
  \centering
	\includegraphics[height=\imgheight,width=\imgwidth]{webglmodels}
  \caption{Modelos 3D {--} Modelos de personagens 3D sendo renderizados com WebGL}
  \label{img:webglmodels}
\end{figure}

\clearpage

Na Figura~\ref{img:emberwind} é possível ver um exemplo do jogo Emberwind
sendo executado utilizando WebGL.

\begin{figure}[H]
  \centering
	\includegraphics[height=\imgheight,width=\imgwidth]{emberwind}
  \caption{Emberwind {--} Utilizando o poder do WebGL para acelerar o processamento}
  \label{img:emberwind}
\end{figure}

\clearpage
